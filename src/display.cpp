#include "display.hpp"
#include "displaydata.hpp"



static const unsigned char arch_bits[] PROGMEM = {
 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00,
 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x00,
 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0xff, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x9e, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x00,
 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
 0x03, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0xc0,
 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x07, 0x00, 0x00,
 0x00, 0xe0, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x1f,
 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0xff,
 0xff, 0x3f, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0xf8, 0x3f, 0x00, 0x00, 0x00,
 0xfc, 0x1f, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0xfc, 0x0f, 0xf0, 0x7f, 0x00,
 0x00, 0x00, 0xfe, 0x0f, 0xe0, 0xff, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0xe0,
 0xff, 0x00, 0x00, 0x00, 0xff, 0x07, 0xc0, 0xff, 0x01, 0x00, 0x00, 0xff,
 0x07, 0xc0, 0xff, 0x01, 0x00, 0x80, 0xff, 0x07, 0xc0, 0xbf, 0x03, 0x00,
 0x80, 0xff, 0x07, 0xc0, 0x7f, 0x00, 0x00, 0xc0, 0xff, 0x07, 0xc0, 0xff,
 0x01, 0x00, 0xe0, 0xff, 0x07, 0xc0, 0xff, 0x03, 0x00, 0xe0, 0xff, 0x07,
 0xc0, 0xff, 0x07, 0x00, 0xf0, 0xff, 0x00, 0x00, 0xfe, 0x1f, 0x00, 0xf0,
 0x1f, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0xf8, 0x07, 0x00, 0x00, 0xc0, 0x3f,
 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x1c, 0x00, 0x00, 0x00,
 0x00, 0x78, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x02, 0x00,
 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};



Display::Display ( ) {
  u8g2 = new U8G2_SH1106_128X64_NONAME_1_SW_I2C ( U8G2_R0, SCL, SDA );
  u8g2->begin ( );

  drawWelcome ( );

  actualPage = 0;
}



void Display::drawHeader ( ) {
  u8g2->drawHLine ( 0, 16, 160 );
  u8g2->setFont ( u8g_font_profont17r );
  u8g2->drawStr ( 0, 15, (const char*) FPSTR ( "sensors" ) );
  u8g2->setFont ( u8g_font_profont15r );
  u8g2->drawStr ( 80, 14, (const char*) FPSTR ( title[actualPage] ) );
}


bool Display::isWelcomeScreen ( ) { return welcomeScreen; }
void Display::welcomeScreenOff ( ) { welcomeScreen = false; }


void Display::drawWelcome ( ) {
  welcomeScreen = true;
  u8g2->firstPage ( );
  do {
    u8g2->setFont ( u8g2_font_10x20_tf );
    u8g2->drawUTF8 ( 50, 14+16, "sys_mon" );
    u8g2->drawXBMP( 0, 16, 50, 48, arch_bits );
  } while ( u8g2->nextPage ( ) );

}



void Display::drawContend ( ) {
  std::string lineText[3];

  switch ( actualPage ) {
  case 0: // CPU
    lineText[0].append ( displayString.t );
    sReplace ( &lineText[0], data->cpu_t );
    lineText[1].append ( displayString.c );
    sReplace ( &lineText[1], data->cpu_c );
    lineText[2].append ( displayString.u );
    sReplace ( &lineText[2], data->cpu_u );
    break;;

  case 1: // LIQUID
    lineText[0].append ( displayString.s );
    sReplace ( &lineText[0], data->liquid_f );
    lineText[1].append ( displayString.s );
    sReplace ( &lineText[1], data->liquid_p );
    lineText[2].append ( displayString.t );
    sReplace ( &lineText[2], data->liquid_t );
    break;;

  case 2: // GPU
    lineText[0].append ( displayString.t );
    sReplace ( &lineText[0], data->gpu_t );
    lineText[1].append ( displayString.u );
    sReplace ( &lineText[1], data->gpu_u );
    lineText[2].append ( displayString.p );
    sReplace ( &lineText[2], data->gpu_p );
    break;;

  case 3: // SYS
    lineText[0].append ( displayString.s );
    sReplace ( &lineText[0], data->fan1_s );
    lineText[1].append ( displayString.s );
    sReplace ( &lineText[1], data->fan2_s );
    lineText[2].append ( displayString.s );
    sReplace ( &lineText[2], data->fan3_s );
    break;;
  }

  u8g2->setFont ( u8g_font_profont15r );

  for (unsigned int counter = 0; counter < 3; counter++ )
    u8g2->drawStr ( 0, line[counter], lineText[counter].c_str ( ) );
}



void Display::draw ( ) {
  u8g2->firstPage ( );

  do {
    drawHeader ( );
    drawContend ( );
  } while ( u8g2->nextPage ( ) );
}



void Display::next ( ) {
  if (actualPage == 3) actualPage = 0;
  else actualPage++;
}



void Display::drawErr ( std::string err ) {
  drawHeader ( );
  u8g2->setFont ( u8g_font_profont15r );
  u8g2->drawStr ( 0, line[0], err.c_str( ) );
}



void Display::setDisplayData ( displayData* dataN ) {
  this->data = dataN;
}


void Display::sReplace ( std::string* input, std::string replace ) {
  std::size_t pos = input->find ( "$" );
  input->replace ( pos, 1, replace );
}
